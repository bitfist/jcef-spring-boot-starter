package io.github.bitfist.jcef.spring.tsobject.internal.processor;

import org.jspecify.annotations.Nullable;

import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

class TypeScriptClassGenerator {

	public String generate(TSClass tsClass, Map<String, TSClass> classModel) {
		var buffer = new StringBuilder();

		// Header comment
		buffer.append("/** AUTO-GENERATED by JCEF TypeScriptProcessor â€“ DO NOT EDIT **/\n\n");

		// Collect imports
		var imports = collectImports(tsClass, classModel);

		// Generate imports
		for (String importClass : imports) {
			var importedClass = findClassBySimpleName(importClass, classModel);
			if (importedClass != null) {
				String importPath = PathUtils.calculateRelativePath(tsClass.getOutputPath(), importedClass.getOutputPath(), importedClass.getTsClassName());
				buffer.append("import type { ").append(importedClass.getTsClassName()).append(" } from '").append(importPath).append("';\n");
			}
		}

		if (!imports.isEmpty()) {
			buffer.append("\n");
		}

		// Generate interface
		buffer.append("export interface ").append(tsClass.getTsClassName()).append(" {\n");

		for (Field field : tsClass.getFields()) {
			buffer.append("    ").append(field.name());
			if (field.isOptional()) {
				buffer.append("?");
			}
			buffer.append(": ").append(field.type()).append(";\n");
		}

		buffer.append("}\n");

		return buffer.toString();
	}

	private Set<String> collectImports(TSClass tsClass, Map<String, TSClass> classModel) {
		var imports = new TreeSet<String>();

		for (Field field : tsClass.getFields()) {
			var type = field.type();

			// Extract base type from arrays and generic types
			type = type.replaceAll("\\[\\]$", "");
			type = type.replaceAll("\\{.*\\}", "");

			// Check if this is a custom type that we're generating
			if (!isPrimitiveType(type) && findClassBySimpleName(type, classModel) != null) {
				imports.add(type);
			}
		}

		return imports;
	}

	private boolean isPrimitiveType(String type) {
		return type.equals("string") || type.equals("number") || type.equals("boolean") || type.equals("any") || type.equals("void") || type.contains("[") || type.contains("{");
	}

	private @Nullable TSClass findClassBySimpleName(String simpleName, Map<String, TSClass> classModel) {
		for (TSClass tsClass : classModel.values()) {
			if (tsClass.getTsClassName().equals(simpleName)) {
				return tsClass;
			}
		}
		return null;
	}
}