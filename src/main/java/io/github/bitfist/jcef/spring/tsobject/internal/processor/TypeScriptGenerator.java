package io.github.bitfist.jcef.spring.tsobject.internal.processor;

import io.github.bitfist.jcef.spring.tsobject.TypeScriptConfiguration;
import lombok.RequiredArgsConstructor;

import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementFilter;
import javax.lang.model.util.Elements;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.util.stream.Collectors.joining;

/**
 * Generates TypeScript files for Java types.
 * Manages dependencies and avoids duplicate generation.
 */
@RequiredArgsConstructor
class TypeScriptGenerator {

    private final String baseOutputPath;
    private final ServiceType serviceType;
    private final Elements elementUtils;
    private final TypeConverter typeConverter = new TypeConverter();
    private final Set<String> processedTypes = new HashSet<>();

    void generate(TypeElement classElement) throws IOException {
        if (processedTypes.contains(classElement.getQualifiedName().toString())) {
            return;
        }

        generateTypeScriptClass(classElement);
        generateDependencies(classElement);
        processedTypes.add(classElement.getQualifiedName().toString());
    }

    /**
     * Retrieves the output path from @TypeScriptConfiguration or returns an empty Optional.
     */
    private String getOutputPath(Element element) {
        var packagePath = elementUtils.getPackageOf(element).getQualifiedName().toString().replace('.', '/');
        var config = element.getAnnotation(TypeScriptConfiguration.class);
        if (config == null) {
            return packagePath;
        }
        if (config.path().isBlank()) {
            return packagePath;
        }
        return config.path();
    }

    private void generateTypeScriptClass(TypeElement classElement) throws IOException {
        var pathOpt = getOutputPath(classElement);
        var content = buildTypeScriptClass(classElement, pathOpt);
        writeFile(classElement, pathOpt, content);
    }

    private void generateTypeDefinition(TypeElement typeElement) throws IOException {
        if (processedTypes.contains(typeElement.getQualifiedName().toString())) {
            return;
        }
        // For dependencies, use the configured path or fall back to the Java package name.
        var path = getOutputPath(typeElement);

        var content = buildTypeScriptDefinition(typeElement, path);
        writeFile(typeElement, path, content);
        processedTypes.add(typeElement.getQualifiedName().toString());

        // Recursively generate dependencies of this dependency
        generateDependencies(typeElement);
    }

    private String buildTypeScriptClass(TypeElement classElement, String tsPath) {
        var className = classElement.getSimpleName().toString();
        var dependencies = new HashSet<TypeMirror>();

        var methodsBuilder = new StringBuilder();
        List<ExecutableElement> methods = ElementFilter.methodsIn(elementUtils.getAllMembers(classElement))
                .stream()
                .filter(m -> !m.getModifiers().contains(Modifier.PRIVATE) && !m.getModifiers().contains(Modifier.STATIC))
                .filter(m -> !m.getEnclosingElement().toString().equals("java.lang.Object"))
                .toList();

        for (ExecutableElement method : methods) {
            methodsBuilder.append(buildTypeScriptMethod(method, classElement.getQualifiedName().toString(), dependencies));
        }

        var service = getCefService();
        var importsBuilder = new StringBuilder();
        var jcefImportPath = PathUtils.getRelativePath(tsPath, "jcef") + "/" + service;
        importsBuilder.append("/** AUTO-GENERATED by JCEF TypeScriptObjectProcessor â€“ DO NOT EDIT **/\n");
        importsBuilder.append("import { ").append(service).append(" } from '").append(jcefImportPath).append("';\n");

        addImports(tsPath, dependencies, importsBuilder);

        return importsBuilder + "\n" +
                "export class " + className + " {\n" +
                methodsBuilder +
                "}\n";
    }

    private String buildTypeScriptMethod(ExecutableElement method, String className, Set<TypeMirror> dependencies) {
        var methodName = method.getSimpleName().toString();
        var params = method.getParameters().stream()
                .map(p -> {
                    collectDependencies(p.asType(), dependencies);
                    return p.getSimpleName() + ": " + typeConverter.toTypeScript(p.asType());
                })
                .collect(joining(", "));

        collectDependencies(method.getReturnType(), dependencies);
        var tsReturnType = typeConverter.toTypeScript(method.getReturnType());
        String promiseReturnType = tsReturnType.equals("void") ? "void" : "Promise<" + tsReturnType + ">";
        var cefResponseType = typeConverter.getCefResponseType(method.getReturnType());

        var paramNames = method.getParameters().stream()
                .map(VariableElement::getSimpleName)
                .collect(joining(", "));

        return "    public static " + methodName + "(" + params + "): " + promiseReturnType + " {\n" +
                "        return " + getCefService() + ".request('" + className + "', '" + methodName + "', {" + paramNames + "}, '" + cefResponseType + "');\n" +
                "    }\n\n";
    }

    private String buildTypeScriptDefinition(TypeElement typeElement, String tsPath) {
        var typeName = typeElement.getSimpleName().toString();
        var dependencies = new HashSet<TypeMirror>();

        var fieldsBuilder = new StringBuilder();
        List<VariableElement> fields = ElementFilter.fieldsIn(elementUtils.getAllMembers(typeElement))
                .stream()
                .filter(f -> !f.getModifiers().contains(Modifier.STATIC))
                .toList();

        for (VariableElement field : fields) {
            collectDependencies(field.asType(), dependencies);
            fieldsBuilder.append("    ")
                    .append(field.getSimpleName())
                    .append(": ")
                    .append(typeConverter.toTypeScript(field.asType()))
                    .append(";\n");
        }

        var importsBuilder = new StringBuilder();
        addImports(tsPath, dependencies, importsBuilder);
        if (!importsBuilder.isEmpty()) importsBuilder.append("\n");


        return importsBuilder +
                "export interface " + typeName + " {\n" +
                fieldsBuilder +
                "}\n";
    }

    private void addImports(String tsPath, Set<TypeMirror> dependencies, StringBuilder importsBuilder) {
        for (TypeMirror dep : dependencies) {
            var depElement = ((DeclaredType) dep).asElement();
            var depPath = getOutputPath(depElement);
            var depName = depElement.getSimpleName().toString();
            var importPath = PathUtils.getRelativePath(tsPath, depPath) + "/" + depName;
            importsBuilder.append("import type { ").append(depName).append(" } from '").append(importPath).append("';\n");
        }
    }

    private void generateDependencies(TypeElement typeElement) throws IOException {
        var dependencies = new HashSet<TypeMirror>();
        // Logic for collecting method and field dependencies (remains unchanged)
        // ...
        List<ExecutableElement> methods = ElementFilter.methodsIn(elementUtils.getAllMembers(typeElement))
                .stream()
                .filter(m -> m.getModifiers().contains(Modifier.PUBLIC) && !m.getModifiers().contains(Modifier.STATIC))
                .toList();

        for (ExecutableElement method : methods) {
            collectDependencies(method.getReturnType(), dependencies);
            for (VariableElement parameter : method.getParameters()) {
                collectDependencies(parameter.asType(), dependencies);
            }
        }

        List<VariableElement> fields = ElementFilter.fieldsIn(elementUtils.getAllMembers(typeElement))
                .stream()
                .filter(f -> !f.getModifiers().contains(Modifier.STATIC))
                .toList();
        for (VariableElement field : fields) {
            collectDependencies(field.asType(), dependencies);
        }

        for (TypeMirror dependency : dependencies) {
            generateTypeDefinition((TypeElement) ((DeclaredType) dependency).asElement());
        }
    }

    private void collectDependencies(TypeMirror type, Set<TypeMirror> dependencies) {
        if (type.getKind() == TypeKind.DECLARED) {
            var declaredType = (DeclaredType) type;
            var element = declaredType.asElement();
            var packageName = elementUtils.getPackageOf(element).getQualifiedName().toString();

            if (!packageName.startsWith("java.")) {
                dependencies.add(declaredType);
            }
            // Also check type arguments for generics
            for (TypeMirror typeArgument : declaredType.getTypeArguments()) {
                collectDependencies(typeArgument, dependencies);
            }
        } else if (type.getKind() == TypeKind.ARRAY) {
            collectDependencies(((javax.lang.model.type.ArrayType) type).getComponentType(), dependencies);
        }
    }

    private String getCefService() {
        if (serviceType == ServiceType.WEB) {
            return "CefRestService";
        }
        return "CefQueryService";
    }

    private void writeFile(Element typeElement, String tsPackageName, String content) throws IOException {
        Path packagePath = Paths.get(baseOutputPath, tsPackageName.replace('.', '/'));
        Files.createDirectories(packagePath);
        var filePath = packagePath.resolve(typeElement.getSimpleName().toString() + ".ts");
        Files.writeString(filePath, content);
    }
}