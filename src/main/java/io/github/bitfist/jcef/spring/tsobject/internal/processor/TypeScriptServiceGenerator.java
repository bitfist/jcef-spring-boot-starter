package io.github.bitfist.jcef.spring.tsobject.internal.processor;

import org.jspecify.annotations.Nullable;

import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

class TypeScriptServiceGenerator {

	public String generate(TSClass tsClass, Map<String, TSClass> classModel) {
		var buffer = new StringBuilder();

		// Header comment
		buffer.append("/** AUTO-GENERATED by JCEF TypeScriptObjectProcessor â€“ DO NOT EDIT **/\n\n");

		// Import CefCommunicationService from jcef folder
		var cefServicePath = calculatePathToJcef(tsClass.getOutputPath());
		buffer.append("import { CefCommunicationService } from '").append(cefServicePath).append("CefCommunicationService';\n");
		buffer.append("import type { ResponseType } from '").append(cefServicePath).append("ResponseType';\n");

		// Collect and generate imports for DTOs
		var imports = collectImports(tsClass, classModel);

		if (!imports.isEmpty()) {
			buffer.append("\n");
			for (String importClass : imports) {
				var importedClass = findClassBySimpleName(importClass, classModel);
				if (importedClass != null) {
					var importPath = PathUtils.calculateRelativePath(tsClass.getOutputPath(), importedClass.getOutputPath(), importedClass.getTsClassName());
					buffer.append("import type { ").append(importedClass.getTsClassName()).append(" } from '").append(importPath).append("';\n");
				}
			}
		}

		buffer.append("\n");

		// Generate service class
		buffer.append("export class ").append(tsClass.getTsClassName()).append(" {\n");
		buffer.append("    private static readonly className = '").append(tsClass.getJavaClassName()).append("';\n\n");

		// Generate methods
		for (Method method : tsClass.getMethods()) {
			generateMethod(buffer, method);
		}

		buffer.append("}\n");

		return buffer.toString();
	}

	private void generateMethod(StringBuilder buffer, Method method) {
		buffer.append("    static async ").append(method.name()).append("(");

		// Parameters
		for (var i = 0; i < method.parameters().size(); i++) {
			var param = method.parameters().get(i);
			buffer.append(param.name()).append(": ").append(param.type());
			if (i < method.parameters().size() - 1) {
				buffer.append(", ");
			}
		}

		buffer.append("): Promise<").append(method.returnType()).append("> {\n");

		// Method body
		buffer.append("        ");
		if (!method.returnType().equals("void")) {
			buffer.append("return ");
		}
		buffer.append("await CefCommunicationService.request");

		if (!method.returnType().equals("void")) {
			buffer.append("<").append(method.returnType()).append(">");
		}

		buffer.append("(\n");
		buffer.append("            this.className,\n");
		buffer.append("            '").append(method.name()).append("',\n");
		buffer.append("            {\n");

		// Parameters object
		for (Parameter param : method.parameters()) {
			buffer.append("                ").append(param.name()).append(",\n");
		}

		buffer.append("            }");

		if (!method.returnType().equals("void")) {
			buffer.append(",\n");
			buffer.append("            ").append(inferResponseType(method.returnType())).append(" as ResponseType");
		}

		buffer.append("\n        );\n");
		buffer.append("    }\n\n");
	}

	private String inferResponseType(String returnType) {
		// Infer the ResponseType based on the TypeScript return type
		return switch (returnType) {
			case "string" -> "'string'";
			case "number" -> "'number'";
			case "boolean" -> "'boolean'";
			case "void", "any" -> "'auto'";
			default -> "'object'"; // For objects, arrays, and custom types
		};
	}

	private Set<String> collectImports(TSClass tsClass, Map<String, TSClass> classModel) {
		var imports = new TreeSet<String>();

		for (Method method : tsClass.getMethods()) {
			// Check return type
			addTypeToImports(method.returnType(), imports, classModel);

			// Check parameter types
			for (Parameter param : method.parameters()) {
				addTypeToImports(param.type(), imports, classModel);
			}
		}

		return imports;
	}

	private void addTypeToImports(String type, Set<String> imports, Map<String, TSClass> classModel) {
		// Extract base type from arrays and generic types
		var baseType = type.replaceAll("\\[\\]$", "");
		baseType = baseType.replaceAll("\\{.*\\}", "");

		// Check if this is a custom type that we're generating
		if (!isPrimitiveType(baseType) && findClassBySimpleName(baseType, classModel) != null) {
			imports.add(baseType);
		}
	}

	private boolean isPrimitiveType(String type) {
		return type.equals("string") || type.equals("number") || type.equals("boolean") ||
				type.equals("any") || type.equals("void") || type.contains("[") || type.contains("{");
	}

	private @Nullable TSClass findClassBySimpleName(String simpleName, Map<String, TSClass> classModel) {
		for (TSClass tsClass : classModel.values()) {
			if (tsClass.getTsClassName().equals(simpleName)) {
				return tsClass;
			}
		}
		return null;
	}

	private String calculatePathToJcef(String fromPath) {
		if (fromPath.isEmpty()) {
			return "./jcef/";
		}

		var parts = fromPath.split("/");

		return "../".repeat(parts.length) + "jcef/";
	}
}